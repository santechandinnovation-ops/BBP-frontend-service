{% extends "base.html" %}

{% block title %}Create Path - Best Bike Paths{% endblock %}

{% block extra_css %}
<style>
    .segment-status-legend {
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
        margin-bottom: 10px;
    }
    .segment-status-legend .legend-item {
        display: flex;
        align-items: center;
        gap: 5px;
        font-size: 0.85rem;
    }
    .legend-color {
        width: 20px;
        height: 4px;
        border-radius: 2px;
    }
    .legend-color.optimal { background-color: #28a745; }
    .legend-color.medium { background-color: #ffc107; }
    .legend-color.sufficient { background-color: #fd7e14; }
    .legend-color.maintenance { background-color: #dc3545; }
    
    .segment-card {
        border-left: 4px solid #ccc;
        transition: border-color 0.3s;
    }
    .segment-card.status-OPTIMAL { border-left-color: #28a745; }
    .segment-card.status-MEDIUM { border-left-color: #ffc107; }
    .segment-card.status-SUFFICIENT { border-left-color: #fd7e14; }
    .segment-card.status-REQUIRES_MAINTENANCE { border-left-color: #dc3545; }
    
    .drawing-hint {
        background-color: #e7f3ff;
        border: 1px solid #b6d4fe;
        border-radius: 8px;
        padding: 10px 15px;
        margin-bottom: 10px;
    }
    .drawing-hint i {
        color: #0d6efd;
    }
    
    .mode-indicator {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 1000;
        background: rgba(0,0,0,0.8);
        color: white;
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 0.9rem;
        display: none;
    }
    .mode-indicator.active {
        display: block;
    }
    .mode-indicator.obstacle-mode {
        background: rgba(255, 193, 7, 0.95);
        color: #000;
    }
    
    #mapContainer {
        position: relative;
    }
    
    .step-badge {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 28px;
        height: 28px;
        border-radius: 50%;
        background-color: #0d6efd;
        color: white;
        font-weight: bold;
        margin-right: 8px;
    }
    .step-badge.completed {
        background-color: #28a745;
    }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid p-3">
    <h2 class="mb-4"><i class="bi bi-pencil-square me-2"></i>Create Manual Path</h2>

    <div class="row">
        <div class="col-md-8">
            <div class="card mb-3">
                <div class="card-body">
                    <h5 class="card-title">
                        <span class="step-badge" id="step1Badge">1</span>
                        Draw Path Segments
                    </h5>
                    <div class="drawing-hint">
                        <i class="bi bi-info-circle me-2"></i>
                        <strong>How to draw:</strong> Click on the map to add points. Each pair of consecutive points creates a segment. 
                        Right-click or use the button to undo the last point.
                    </div>
                    <div id="mapContainer" class="map-container" style="position: relative;">
                        <div id="modeIndicator" class="mode-indicator">
                            <i class="bi bi-geo-alt-fill me-2"></i>
                            <span id="modeText">Drawing Mode</span>
                        </div>
                    </div>
                    <div class="mt-3 d-flex gap-2 flex-wrap">
                        <button id="undoPointBtn" class="btn btn-warning btn-sm" disabled>
                            <i class="bi bi-arrow-counterclockwise"></i> Undo Last Point
                        </button>
                        <button id="clearPathBtn" class="btn btn-danger btn-sm" disabled>
                            <i class="bi bi-trash"></i> Clear All
                        </button>
                        <button id="finishDrawingBtn" class="btn btn-success btn-sm" disabled>
                            <i class="bi bi-check-lg"></i> Finish Drawing
                        </button>
                    </div>
                    <div class="mt-2">
                        <small class="text-muted" id="pointsCounter">Points: 0 | Segments: 0</small>
                    </div>
                </div>
            </div>
        </div>

        <div class="col-md-4">
            <div class="card" id="pathInfoCard" style="display: none;">
                <div class="card-body">
                    <h5 class="card-title"><i class="bi bi-info-circle me-2"></i>Path Information</h5>
                    <div class="mb-3">
                        <label class="form-label">Name <small class="text-muted">(Optional)</small></label>
                        <input type="text" class="form-control" id="pathName" placeholder="e.g., Via Milano - Piazza Duomo">
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Description <small class="text-muted">(Optional)</small></label>
                        <textarea class="form-control" id="pathDescription" rows="3" placeholder="Describe your path..."></textarea>
                    </div>
                    <div class="form-check mb-3">
                        <input class="form-check-input" type="checkbox" id="publishable">
                        <label class="form-check-label" for="publishable">
                            <i class="bi bi-globe me-1"></i> Make this path public
                        </label>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="segmentsSection" style="display: none;">
        <div class="card mt-3">
            <div class="card-body">
                <h5 class="card-title">
                    <span class="step-badge" id="step2Badge">2</span>
                    Configure Segment Status
                </h5>
                <p class="text-muted small mb-3">
                    <i class="bi bi-palette me-1"></i>
                    Set the condition status for each segment. The path on the map will update colors accordingly.
                </p>
                <div class="segment-status-legend">
                    <div class="legend-item"><span class="legend-color optimal"></span> Optimal</div>
                    <div class="legend-item"><span class="legend-color medium"></span> Medium</div>
                    <div class="legend-item"><span class="legend-color sufficient"></span> Sufficient</div>
                    <div class="legend-item"><span class="legend-color maintenance"></span> Requires Maintenance</div>
                </div>
                <div id="segmentsList"></div>
            </div>
        </div>

        <div class="card mt-3">
            <div class="card-body">
                <h5 class="card-title">
                    <span class="step-badge">3</span>
                    Add Obstacles <small class="text-muted">(Optional)</small>
                </h5>
                <p class="text-muted small mb-3">
                    <i class="bi bi-exclamation-triangle me-1"></i>
                    Mark any obstacles or hazards along the path to warn other cyclists.
                </p>
                <div id="obstaclesList"><p class="text-muted">No obstacles added yet</p></div>
                <button id="addObstacleBtn" class="btn btn-warning mt-2">
                    <i class="bi bi-plus-circle me-1"></i> Add Obstacle
                </button>
            </div>
        </div>

        <div class="text-center mt-4 mb-5">
            <button id="savePathBtn" class="btn btn-success btn-lg px-5">
                <i class="bi bi-save me-2"></i> Save Path
            </button>
        </div>
    </div>
</div>

<div class="modal fade" id="obstacleModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header bg-warning">
                <h5 class="modal-title"><i class="bi bi-exclamation-triangle me-2"></i>New Obstacle</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <p class="text-muted mb-3">
                    <i class="bi bi-info-circle me-1"></i>
                    Configure the obstacle details, then click "Confirm" to place it on the map.
                </p>
                <div class="mb-3">
                    <label class="form-label fw-semibold">Type</label>
                    <select class="form-select" id="obstacleType">
                        <option value="POTHOLE">üï≥Ô∏è Pothole</option>
                        <option value="ROUGH_SURFACE">ü™® Rough Surface</option>
                        <option value="DEBRIS">üóëÔ∏è Debris</option>
                        <option value="CONSTRUCTION">üöß Construction</option>
                        <option value="OTHER">‚ö†Ô∏è Other</option>
                    </select>
                </div>
                <div class="mb-3">
                    <label class="form-label fw-semibold">Severity</label>
                    <select class="form-select" id="obstacleSeverity">
                        <option value="MINOR">üü¢ Minor - Can be avoided easily</option>
                        <option value="MODERATE">üü° Moderate - Requires attention</option>
                        <option value="SEVERE">üî¥ Severe - Dangerous</option>
                    </select>
                </div>
                <div class="mb-3">
                    <label class="form-label fw-semibold">Description <small class="text-muted">(Optional)</small></label>
                    <input type="text" class="form-control" id="obstacleDescription" placeholder="e.g., Large pothole near the curb">
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-warning" id="confirmObstacleBtn">
                    <i class="bi bi-cursor me-1"></i> Confirm & Place on Map
                </button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
    if (!requireAuth()) {
        throw new Error('Authentication required');
    }

    let map;
    let pathPoints = [];
    let segments = [];
    let segmentPolylines = [];
    let obstacles = [];
    let obstacleMarkers = [];
    let pointMarkers = [];
    let isAddingObstacle = false;
    let obstacleModal;
    let pendingObstacle = null;
    let isLoadingRoute = false;

    // Status colors for segments
    const statusColors = {
        'OPTIMAL': '#28a745',
        'MEDIUM': '#ffc107', 
        'SUFFICIENT': '#fd7e14',
        'REQUIRES_MAINTENANCE': '#dc3545'
    };

    // Decode polyline from OSRM (uses polyline encoding)
    function decodePolyline(encoded) {
        let points = [];
        let index = 0, lat = 0, lng = 0;

        while (index < encoded.length) {
            let b, shift = 0, result = 0;
            do {
                b = encoded.charCodeAt(index++) - 63;
                result |= (b & 0x1f) << shift;
                shift += 5;
            } while (b >= 0x20);
            let dlat = ((result & 1) ? ~(result >> 1) : (result >> 1));
            lat += dlat;

            shift = 0;
            result = 0;
            do {
                b = encoded.charCodeAt(index++) - 63;
                result |= (b & 0x1f) << shift;
                shift += 5;
            } while (b >= 0x20);
            let dlng = ((result & 1) ? ~(result >> 1) : (result >> 1));
            lng += dlng;

            points.push([lat / 1e5, lng / 1e5]);
        }
        return points;
    }

    // Get route from OSRM that follows actual roads
    async function getRouteOnRoad(startLat, startLng, endLat, endLng) {
        try {
            // Using OSRM demo server - for production use your own server
            const url = `https://router.project-osrm.org/route/v1/bike/${startLng},${startLat};${endLng},${endLat}?overview=full&geometries=polyline`;
            
            const response = await fetch(url);
            const data = await response.json();
            
            if (data.code === 'Ok' && data.routes && data.routes.length > 0) {
                const route = data.routes[0];
                const routePoints = decodePolyline(route.geometry);
                return {
                    points: routePoints,
                    distance: route.distance, // in meters
                    duration: route.duration  // in seconds
                };
            }
            return null;
        } catch (error) {
            console.error('Error fetching route:', error);
            return null;
        }
    }

    function initMap() {
        map = L.map('mapContainer').setView([45.4642, 9.1900], 14);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors'
        }).addTo(map);

        map.on('click', handleMapClick);
        map.on('contextmenu', () => undoLastPoint());
        
        // Initialize modal
        obstacleModal = new bootstrap.Modal(document.getElementById('obstacleModal'));
    }

    async function handleMapClick(e) {
        if (isAddingObstacle) {
            placeObstacle(e.latlng.lat, e.latlng.lng);
            return;
        }

        // Only allow adding points if not in segment editing mode
        if (document.getElementById('segmentsSection').style.display !== 'none') {
            return;
        }

        // Prevent multiple rapid clicks while loading
        if (isLoadingRoute) {
            return;
        }

        const newPoint = [e.latlng.lat, e.latlng.lng];
        pathPoints.push(newPoint);
        
        // Add marker for the point
        addPointMarker(newPoint, pathPoints.length - 1);
        
        // Create segment when we have at least 2 points
        if (pathPoints.length >= 2) {
            isLoadingRoute = true;
            showModeIndicator('üîÑ Calculating route on road...', false);
            
            const segIndex = pathPoints.length - 2;
            const startPoint = pathPoints[segIndex];
            const endPoint = pathPoints[segIndex + 1];
            
            // Get route that follows roads
            const routeData = await getRouteOnRoad(
                startPoint[0], startPoint[1],
                endPoint[0], endPoint[1]
            );
            
            segments.push({
                startIndex: segIndex,
                endIndex: segIndex + 1,
                status: 'OPTIMAL',
                streetName: '',
                routePoints: routeData ? routeData.points : [startPoint, endPoint],
                distance: routeData ? routeData.distance : null,
                duration: routeData ? routeData.duration : null
            });
            
            isLoadingRoute = false;
            hideModeIndicator();
            
            if (!routeData) {
                showAlert('Could not find road route, using straight line', 'warning');
            }
        }
        
        updatePathDisplay();
        updateButtons();
        updatePointsCounter();
    }

    function addPointMarker(point, index) {
        const isFirst = index === 0;
        const marker = L.circleMarker(point, {
            radius: 8,
            fillColor: isFirst ? '#28a745' : '#007bff',
            color: '#fff',
            weight: 2,
            fillOpacity: 1
        }).addTo(map);
        
        marker.bindTooltip(`Point ${index + 1}`, { permanent: false });
        pointMarkers.push(marker);
    }

    function updatePointMarkers() {
        // Update colors - first green, last red, others blue
        pointMarkers.forEach((marker, idx) => {
            let color = '#007bff';
            if (idx === 0) color = '#28a745';
            else if (idx === pathPoints.length - 1) color = '#dc3545';
            
            marker.setStyle({ fillColor: color });
        });
    }

    function updatePathDisplay() {
        // Clear existing polylines
        segmentPolylines.forEach(p => map.removeLayer(p));
        segmentPolylines = [];

        // Draw each segment with its status color (using road-snapped route)
        segments.forEach((segment, index) => {
            const routePoints = segment.routePoints || [
                pathPoints[segment.startIndex],
                pathPoints[segment.endIndex]
            ];
            
            const color = statusColors[segment.status] || '#007bff';
            const polyline = L.polyline(routePoints, {
                color: color,
                weight: 6,
                opacity: 0.8
            }).addTo(map);
            
            // Add tooltip with segment info including distance
            let tooltipText = `Segment ${index + 1}: ${segment.status}`;
            if (segment.distance) {
                tooltipText += ` (${(segment.distance / 1000).toFixed(2)} km)`;
            }
            polyline.bindTooltip(tooltipText, {
                permanent: false,
                direction: 'center'
            });
            
            segmentPolylines.push(polyline);
        });

        // Update point markers colors
        updatePointMarkers();
    }

    function updatePointsCounter() {
        const segCount = segments.length;
        let totalDistance = 0;
        segments.forEach(seg => {
            if (seg.distance) totalDistance += seg.distance;
        });
        
        let counterText = `Points: ${pathPoints.length} | Segments: ${segCount}`;
        if (totalDistance > 0) {
            counterText += ` | Total: ${(totalDistance / 1000).toFixed(2)} km`;
        }
        document.getElementById('pointsCounter').textContent = counterText;
    }

    function undoLastPoint() {
        if (pathPoints.length > 0 && document.getElementById('segmentsSection').style.display === 'none' && !isLoadingRoute) {
            pathPoints.pop();
            
            // Remove last point marker
            if (pointMarkers.length > 0) {
                const lastMarker = pointMarkers.pop();
                map.removeLayer(lastMarker);
            }
            
            if (segments.length > 0) {
                segments.pop();
            }
            
            updatePathDisplay();
            updateButtons();
            updatePointsCounter();
        }
    }

    function clearPath() {
        pathPoints = [];
        segments = [];
        
        // Clear all polylines and markers
        segmentPolylines.forEach(p => map.removeLayer(p));
        segmentPolylines = [];
        
        pointMarkers.forEach(m => map.removeLayer(m));
        pointMarkers = [];
        
        obstacleMarkers.forEach(m => map.removeLayer(m));
        obstacleMarkers = [];
        obstacles = [];
        
        updateButtons();
        updatePointsCounter();
        document.getElementById('pathInfoCard').style.display = 'none';
        document.getElementById('segmentsSection').style.display = 'none';
        document.getElementById('step1Badge').classList.remove('completed');
        document.getElementById('step1Badge').innerHTML = '1';
    }

    function updateButtons() {
        document.getElementById('undoPointBtn').disabled = pathPoints.length === 0 || isLoadingRoute;
        document.getElementById('clearPathBtn').disabled = pathPoints.length === 0;
        document.getElementById('finishDrawingBtn').disabled = pathPoints.length < 2 || isLoadingRoute;
    }

    document.getElementById('undoPointBtn').addEventListener('click', undoLastPoint);
    document.getElementById('clearPathBtn').addEventListener('click', clearPath);

    document.getElementById('finishDrawingBtn').addEventListener('click', () => {
        if (pathPoints.length < 2) {
            showAlert('Path must have at least 2 points', 'warning');
            return;
        }

        document.getElementById('pathInfoCard').style.display = 'block';
        document.getElementById('segmentsSection').style.display = 'block';
        document.getElementById('step1Badge').classList.add('completed');
        document.getElementById('step1Badge').innerHTML = '<i class="bi bi-check"></i>';

        // Hide point markers but keep polylines
        pointMarkers.forEach(m => m.setStyle({ opacity: 0.5, fillOpacity: 0.5 }));
        
        renderSegments();
        updatePathDisplay();
        showAlert('Path completed! Now configure segment status.', 'success');
    });

    function renderSegments() {
        let html = '';
        segments.forEach((segment, index) => {
            const distanceInfo = segment.distance 
                ? `<span class="badge bg-info ms-2">${(segment.distance / 1000).toFixed(2)} km</span>`
                : '';
            
            html += `
                <div class="card mb-2 segment-card status-${segment.status}" id="segmentCard${index}">
                    <div class="card-body py-2">
                        <div class="d-flex justify-content-between align-items-center mb-2">
                            <h6 class="mb-0">
                                <i class="bi bi-signpost-split me-1"></i>
                                Segment ${index + 1}
                                ${distanceInfo}
                            </h6>
                            <span class="badge bg-secondary">
                                Point ${segment.startIndex + 1} ‚Üí ${segment.endIndex + 1}
                            </span>
                        </div>
                        <div class="row g-2">
                            <div class="col-md-6">
                                <input type="text" class="form-control form-control-sm" 
                                    placeholder="Street name (optional)"
                                    value="${segment.streetName}" 
                                    onchange="updateSegmentName(${index}, this.value)">
                            </div>
                            <div class="col-md-6">
                                <select class="form-select form-select-sm" 
                                    onchange="updateSegmentStatus(${index}, this.value)"
                                    id="segmentStatus${index}">
                                    <option value="OPTIMAL" ${segment.status === 'OPTIMAL' ? 'selected' : ''}>üü¢ Optimal</option>
                                    <option value="MEDIUM" ${segment.status === 'MEDIUM' ? 'selected' : ''}>üü° Medium</option>
                                    <option value="SUFFICIENT" ${segment.status === 'SUFFICIENT' ? 'selected' : ''}>üü† Sufficient</option>
                                    <option value="REQUIRES_MAINTENANCE" ${segment.status === 'REQUIRES_MAINTENANCE' ? 'selected' : ''}>üî¥ Requires Maintenance</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        });
        
        if (segments.length === 0) {
            html = '<p class="text-muted">No segments created yet. Draw at least 2 points on the map.</p>';
        }
        
        document.getElementById('segmentsList').innerHTML = html;
    }

    function updateSegmentName(index, name) {
        segments[index].streetName = name;
    }

    function updateSegmentStatus(index, status) {
        segments[index].status = status;
        
        // Update card border color
        const card = document.getElementById(`segmentCard${index}`);
        card.className = `card mb-2 segment-card status-${status}`;
        
        // Update polyline color on map
        updatePathDisplay();
    }

    function showModeIndicator(text, isObstacleMode = false) {
        const indicator = document.getElementById('modeIndicator');
        const modeText = document.getElementById('modeText');
        modeText.textContent = text;
        indicator.classList.add('active');
        if (isObstacleMode) {
            indicator.classList.add('obstacle-mode');
        } else {
            indicator.classList.remove('obstacle-mode');
        }
    }

    function hideModeIndicator() {
        document.getElementById('modeIndicator').classList.remove('active', 'obstacle-mode');
    }

    // Helper function to find the nearest point on the path to a given location
    function findNearestPointOnPath(lat, lng) {
        let minDistance = Infinity;
        let nearestPoint = null;
        let nearestSegmentIndex = -1;

        segments.forEach((segment, segIndex) => {
            const routePoints = segment.routePoints || [
                pathPoints[segment.startIndex],
                pathPoints[segment.endIndex]
            ];

            // Check each point in the route
            for (let i = 0; i < routePoints.length; i++) {
                const point = routePoints[i];
                const distance = getDistanceInMeters(lat, lng, point[0], point[1]);
                
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestPoint = point;
                    nearestSegmentIndex = segIndex;
                }
            }

            // Also check points along line segments for better accuracy
            for (let i = 0; i < routePoints.length - 1; i++) {
                const p1 = routePoints[i];
                const p2 = routePoints[i + 1];
                const projected = projectPointOnLine(lat, lng, p1[0], p1[1], p2[0], p2[1]);
                const distance = getDistanceInMeters(lat, lng, projected.lat, projected.lng);
                
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestPoint = [projected.lat, projected.lng];
                    nearestSegmentIndex = segIndex;
                }
            }
        });

        return {
            point: nearestPoint,
            distance: minDistance,
            segmentIndex: nearestSegmentIndex
        };
    }

    // Calculate distance between two points in meters using Haversine formula
    function getDistanceInMeters(lat1, lng1, lat2, lng2) {
        const R = 6371000; // Earth's radius in meters
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLng = (lng2 - lng1) * Math.PI / 180;
        const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                  Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                  Math.sin(dLng/2) * Math.sin(dLng/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
    }

    // Project a point onto a line segment
    function projectPointOnLine(px, py, x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        
        if (dx === 0 && dy === 0) {
            return { lat: x1, lng: y1 };
        }
        
        const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / (dx * dx + dy * dy)));
        
        return {
            lat: x1 + t * dx,
            lng: y1 + t * dy
        };
    }

    // Obstacle handling - improved flow
    document.getElementById('addObstacleBtn').addEventListener('click', () => {
        if (segments.length === 0) {
            showAlert('Please draw a path first before adding obstacles', 'warning');
            return;
        }
        
        // Reset form
        document.getElementById('obstacleType').value = 'POTHOLE';
        document.getElementById('obstacleSeverity').value = 'MINOR';
        document.getElementById('obstacleDescription').value = '';
        
        // Show modal to configure obstacle first
        obstacleModal.show();
    });

    document.getElementById('confirmObstacleBtn').addEventListener('click', () => {
        // Store pending obstacle configuration
        pendingObstacle = {
            type: document.getElementById('obstacleType').value,
            severity: document.getElementById('obstacleSeverity').value,
            description: document.getElementById('obstacleDescription').value || null
        };
        
        // Close modal
        obstacleModal.hide();
        
        // Enable obstacle placement mode
        isAddingObstacle = true;
        showModeIndicator('üéØ Click on or near the path to place the obstacle', true);
        showAlert('Click on the path (or nearby) to place the obstacle. It will be snapped to the nearest point on the route.', 'info');
    });

    // Cancel obstacle placement when modal is closed without confirming
    document.getElementById('obstacleModal').addEventListener('hidden.bs.modal', () => {
        if (!isAddingObstacle) {
            pendingObstacle = null;
        }
    });

    function placeObstacle(lat, lng) {
        if (!isAddingObstacle || !pendingObstacle) return;

        // Find the nearest point on the path and snap the obstacle to it
        const nearest = findNearestPointOnPath(lat, lng);
        
        // Maximum distance allowed (100 meters from the path)
        const maxDistance = 100;
        
        if (nearest.distance > maxDistance) {
            showAlert(`Please click closer to the path. The obstacle must be within ${maxDistance}m of the route.`, 'warning');
            return; // Don't place the obstacle, let the user try again
        }

        // Use the snapped coordinates (nearest point on path)
        const snappedLat = nearest.point[0];
        const snappedLng = nearest.point[1];

        const obstacle = {
            latitude: snappedLat,
            longitude: snappedLng,
            type: pendingObstacle.type,
            severity: pendingObstacle.severity,
            description: pendingObstacle.description
        };

        obstacles.push(obstacle);

        // Create marker with severity-based styling
        const severityColors = {
            'MINOR': '#28a745',
            'MODERATE': '#ffc107',
            'SEVERE': '#dc3545'
        };
        
        const marker = L.marker([snappedLat, snappedLng], {
            icon: L.divIcon({
                className: 'obstacle-marker',
                html: `<i class="bi bi-exclamation-triangle-fill" style="font-size: 24px; color: ${severityColors[obstacle.severity]};"></i>`,
                iconSize: [24, 24],
                iconAnchor: [12, 24]
            })
        }).addTo(map);
        
        marker.bindTooltip(`${obstacle.type} (${obstacle.severity})`, { permanent: false });
        obstacleMarkers.push(marker);

        renderObstacles();
        
        // Reset obstacle mode
        isAddingObstacle = false;
        pendingObstacle = null;
        hideModeIndicator();
        
        showAlert('Obstacle added successfully!', 'success');
    }

    function renderObstacles() {
        let html = '';
        if (obstacles.length === 0) {
            html = '<p class="text-muted">No obstacles added yet</p>';
        } else {
            obstacles.forEach((obs, index) => {
                const severityBadge = {
                    'MINOR': 'bg-success',
                    'MODERATE': 'bg-warning text-dark',
                    'SEVERE': 'bg-danger'
                };
                
                html += `
                    <div class="card mb-2">
                        <div class="card-body py-2 d-flex justify-content-between align-items-center">
                            <div>
                                <strong>${getObstacleEmoji(obs.type)} ${obs.type.replace('_', ' ')}</strong>
                                <span class="badge ${severityBadge[obs.severity]} ms-2">${obs.severity}</span>
                                ${obs.description ? `<br><small class="text-muted">${obs.description}</small>` : ''}
                            </div>
                            <button class="btn btn-sm btn-outline-danger" onclick="removeObstacle(${index})" title="Remove obstacle">
                                <i class="bi bi-trash"></i>
                            </button>
                        </div>
                    </div>
                `;
            });
        }
        document.getElementById('obstaclesList').innerHTML = html;
    }

    function getObstacleEmoji(type) {
        const emojis = {
            'POTHOLE': 'üï≥Ô∏è',
            'ROUGH_SURFACE': 'ü™®',
            'DEBRIS': 'üóëÔ∏è',
            'CONSTRUCTION': 'üöß',
            'OTHER': '‚ö†Ô∏è'
        };
        return emojis[type] || '‚ö†Ô∏è';
    }

    function removeObstacle(index) {
        obstacles.splice(index, 1);
        
        // Remove marker from map
        if (obstacleMarkers[index]) {
            map.removeLayer(obstacleMarkers[index]);
            obstacleMarkers.splice(index, 1);
        }
        
        renderObstacles();
        showAlert('Obstacle removed', 'info');
    }

    document.getElementById('savePathBtn').addEventListener('click', async () => {
        if (segments.length === 0) {
            showAlert('Please create at least one segment', 'warning');
            return;
        }

        const btn = document.getElementById('savePathBtn');
        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span> Saving...';

        // Build segments with route points for accurate road-snapped coordinates
        const pathData = {
            name: document.getElementById('pathName').value || null,
            description: document.getElementById('pathDescription').value || null,
            publishable: document.getElementById('publishable').checked,
            segments: segments.map((seg, index) => {
                // Use the first and last point of the route for start/end coordinates
                const routePoints = seg.routePoints || [
                    pathPoints[seg.startIndex],
                    pathPoints[seg.endIndex]
                ];
                const startPoint = routePoints[0];
                const endPoint = routePoints[routePoints.length - 1];
                
                return {
                    streetName: seg.streetName || null,
                    status: seg.status,
                    startLatitude: startPoint[0],
                    startLongitude: startPoint[1],
                    endLatitude: endPoint[0],
                    endLongitude: endPoint[1],
                    order: index,
                    // Include all intermediate points for accurate path representation
                    routeGeometry: routePoints,
                    distance: seg.distance || null
                };
            }),
            obstacles: obstacles
        };

        try {
            const response = await API.paths.createManual(pathData);
            showAlert('Path saved successfully!', 'success');
            setTimeout(() => {
                window.location.href = '/search';
            }, 1500);
        } catch (error) {
            showAlert('Failed to save path: ' + error.message, 'danger');
            btn.disabled = false;
            btn.innerHTML = '<i class="bi bi-save me-2"></i> Save Path';
        }
    });

    initMap();
</script>
{% endblock %}
