{% extends "base.html" %}

{% block title %}Recording Trip - Best Bike Paths{% endblock %}

{% block content %}
<div class="container-fluid p-3">
    <div class="text-center mb-3">
        <h2 class="text-success">Recording...</h2>
        <div id="timer" class="h4 text-muted">00:00:00</div>
    </div>

    <div class="row g-3 mb-3">
        <div class="col-4">
            <div class="card trip-stat-card">
                <div class="trip-stat-value" id="distance">0.00</div>
                <div class="trip-stat-label">km</div>
            </div>
        </div>
        <div class="col-4">
            <div class="card trip-stat-card">
                <div class="trip-stat-value" id="speed">0.0</div>
                <div class="trip-stat-label">km/h</div>
            </div>
        </div>
        <div class="col-4">
            <div class="card trip-stat-card">
                <div class="trip-stat-value" id="points">0</div>
                <div class="trip-stat-label">points</div>
            </div>
        </div>
    </div>

    <div id="mapContainer" class="map-container mb-3"></div>

    <div class="text-center">
        <button id="stopTripBtn" class="btn btn-danger btn-lg btn-lg-mobile">
            <i class="bi bi-stop-circle"></i> Stop Recording
        </button>
    </div>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
    if (!requireAuth()) {
        throw new Error('Authentication required');
    }

    const activeTripData = localStorage.getItem('activeTrip');
    if (!activeTripData) {
        window.location.href = '/trip/dashboard';
        throw new Error('No active trip');
    }

    const activeTrip = JSON.parse(activeTripData);
    const tripId = activeTrip.tripId;
    const startTime = new Date(activeTrip.startTime);

    let map, pathPolyline, currentMarker;
    let watchId = null;
    let coordinateCount = 0;
    let pathCoordinates = [];  // For map display [lat, lon]
    let allCoordinates = [];   // All coordinates with full data for batch upload

    function initMap() {
        map = L.map('mapContainer').setView([45.4642, 9.1900], 15);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap contributors'
        }).addTo(map);

        pathPolyline = L.polyline([], {
            color: '#28a745',
            weight: 4,
            opacity: 0.7
        }).addTo(map);
    }

    function updateTimer() {
        const now = new Date();
        const elapsed = Math.floor((now - startTime) / 1000);
        const hours = Math.floor(elapsed / 3600);
        const minutes = Math.floor((elapsed % 3600) / 60);
        const seconds = elapsed % 60;

        document.getElementById('timer').textContent =
            `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    }

    // Calculate distance between two points using Haversine formula (returns meters)
    function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371000; // Earth's radius in meters
        const phi1 = lat1 * Math.PI / 180;
        const phi2 = lat2 * Math.PI / 180;
        const deltaPhi = (lat2 - lat1) * Math.PI / 180;
        const deltaLambda = (lon2 - lon1) * Math.PI / 180;
        
        const a = Math.sin(deltaPhi/2) * Math.sin(deltaPhi/2) +
                  Math.cos(phi1) * Math.cos(phi2) *
                  Math.sin(deltaLambda/2) * Math.sin(deltaLambda/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        
        return R * c;
    }

    // Calculate and display local statistics
    function updateLocalStats() {
        if (allCoordinates.length < 2) return;
        
        let totalDistance = 0;
        let maxSpeed = 0;
        
        for (let i = 1; i < allCoordinates.length; i++) {
            const prev = allCoordinates[i - 1];
            const curr = allCoordinates[i];
            
            const segmentDist = calculateDistance(prev.latitude, prev.longitude, curr.latitude, curr.longitude);
            
            // Skip GPS noise (< 1 meter)
            if (segmentDist < 1) continue;
            
            totalDistance += segmentDist;
            
            const timeDiff = (new Date(curr.timestamp) - new Date(prev.timestamp)) / 1000;
            if (timeDiff > 0) {
                const speed = segmentDist / timeDiff; // m/s
                // Filter unrealistic speeds (> 50 m/s = 180 km/h)
                if (speed < 50) {
                    maxSpeed = Math.max(maxSpeed, speed);
                }
            }
        }
        
        // Update UI with local calculations
        document.getElementById('distance').textContent = (totalDistance / 1000).toFixed(2);
        document.getElementById('points').textContent = allCoordinates.length;
        
        // Calculate current speed from last two points
        if (allCoordinates.length >= 2) {
            const last = allCoordinates[allCoordinates.length - 1];
            const prev = allCoordinates[allCoordinates.length - 2];
            const timeDiff = (new Date(last.timestamp) - new Date(prev.timestamp)) / 1000;
            if (timeDiff > 0) {
                const dist = calculateDistance(prev.latitude, prev.longitude, last.latitude, last.longitude);
                const currentSpeed = (dist / timeDiff) * 3.6; // Convert m/s to km/h
                if (currentSpeed < 180) { // Filter unrealistic speeds
                    document.getElementById('speed').textContent = currentSpeed.toFixed(1);
                }
            }
        }
    }

    let gpsErrorCount = 0;
    const MAX_GPS_ERRORS = 5;
    
    // Detect iOS devices
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

    // Get user-friendly GPS error message
    function getGPSErrorMessage(error) {
        switch(error.code) {
            case 1:
                return isIOS 
                    ? 'Location access lost. Check Settings > Privacy & Security > Location Services.'
                    : 'Location access denied. Please check browser permissions.';
            case 2:
                return 'GPS signal lost. Move to an open area for better reception.';
            case 3:
                return 'GPS signal weak. Continuing to try...';
            default:
                return 'GPS error occurred. Attempting to reconnect...';
        }
    }

    function startGPSTracking() {
        if (!('geolocation' in navigator)) {
            showAlert('Geolocation not supported', 'danger');
            return;
        }

        // Use initial position from localStorage if available
        const activeTripStorage = localStorage.getItem('activeTrip');
        if (activeTripStorage) {
            const tripData = JSON.parse(activeTripStorage);
            if (tripData.initialPosition) {
                const { lat, lon } = tripData.initialPosition;
                map.setView([lat, lon], 16);
                currentMarker = L.marker([lat, lon]).addTo(map);
                pathCoordinates.push([lat, lon]);
                pathPolyline.setLatLngs(pathCoordinates);
                
                // Add initial position to coordinates
                allCoordinates.push({
                    latitude: lat,
                    longitude: lon,
                    timestamp: activeTrip.startTime,
                    elevation: null
                });
            }
        }

        // iOS-optimized geolocation options
        const geoOptions = {
            enableHighAccuracy: true,
            maximumAge: isIOS ? 5000 : 3000,
            timeout: isIOS ? 30000 : 15000
        };

        watchId = navigator.geolocation.watchPosition(
            (position) => {
                gpsErrorCount = 0;
                
                const lat = position.coords.latitude;
                const lon = position.coords.longitude;
                const elevation = position.coords.altitude;
                const accuracy = position.coords.accuracy;

                // Only add point if accuracy is reasonable (< 100 meters)
                if (accuracy && accuracy > 100) {
                    console.log('Skipping low accuracy position:', accuracy);
                    return;
                }

                // Update map display
                pathCoordinates.push([lat, lon]);
                pathPolyline.setLatLngs(pathCoordinates);

                if (currentMarker) {
                    map.removeLayer(currentMarker);
                }
                currentMarker = L.marker([lat, lon]).addTo(map);
                map.setView([lat, lon], map.getZoom());

                // Store coordinate locally (will be sent in batch at the end)
                allCoordinates.push({
                    latitude: lat,
                    longitude: lon,
                    timestamp: new Date().toISOString(),
                    elevation: elevation
                });
                
                // Update local statistics
                updateLocalStats();
            },
            (error) => {
                console.error('GPS error:', error.code, error.message);
                gpsErrorCount++;
                
                if (gpsErrorCount <= MAX_GPS_ERRORS) {
                    if (error.code === 3) {
                        console.log('GPS timeout, waiting for signal...');
                    } else {
                        showAlert(getGPSErrorMessage(error), 'warning');
                    }
                } else {
                    showAlert('GPS connection unstable. Your trip is still being recorded when signal is available.', 'warning');
                    gpsErrorCount = 0;
                }
            },
            geoOptions
        );
    }

    document.getElementById('stopTripBtn').addEventListener('click', async () => {
        const btn = document.getElementById('stopTripBtn');
        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Saving trip...';

        // Stop GPS tracking
        if (watchId) {
            navigator.geolocation.clearWatch(watchId);
        }

        try {
            // Send all coordinates in a single batch request
            if (allCoordinates.length > 0) {
                btn.innerHTML = `<span class="spinner-border spinner-border-sm"></span> Uploading ${allCoordinates.length} points...`;
                
                await API.trips.addCoordinatesBatch(tripId, allCoordinates);
                console.log(`Successfully uploaded ${allCoordinates.length} coordinates`);
            }

            btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Calculating statistics...';
            
            // Complete the trip
            const endTime = new Date().toISOString();
            await API.trips.complete(tripId, endTime);

            localStorage.removeItem('activeTrip');
            window.location.href = `/trip/summary/${tripId}`;
        } catch (error) {
            console.error('Error completing trip:', error);
            showAlert('Failed to complete trip: ' + error.message, 'danger');
            btn.disabled = false;
            btn.innerHTML = '<i class="bi bi-stop-circle"></i> Stop Recording';
        }
    });

    initMap();
    startGPSTracking();
    setInterval(updateTimer, 1000);
    // Update local stats every 2 seconds
    setInterval(updateLocalStats, 2000);
</script>
{% endblock %}
