{% extends "base.html" %}

{% block title %}Recording Trip - Best Bike Paths{% endblock %}

{% block content %}
<div class="container-fluid p-3">
    <div class="text-center mb-3">
        <h2 class="text-success">Recording...</h2>
        <div id="timer" class="h4 text-muted">00:00:00</div>
    </div>

    <div class="row g-3 mb-3">
        <div class="col-4">
            <div class="card trip-stat-card">
                <div class="trip-stat-value" id="distance">0.00</div>
                <div class="trip-stat-label">km</div>
            </div>
        </div>
        <div class="col-4">
            <div class="card trip-stat-card">
                <div class="trip-stat-value" id="speed">0.0</div>
                <div class="trip-stat-label">km/h</div>
            </div>
        </div>
        <div class="col-4">
            <div class="card trip-stat-card">
                <div class="trip-stat-value" id="points">0</div>
                <div class="trip-stat-label">points</div>
            </div>
        </div>
    </div>

    <div id="mapContainer" class="map-container mb-3"></div>

    <div class="text-center">
        <button id="stopTripBtn" class="btn btn-danger btn-lg btn-lg-mobile">
            <i class="bi bi-stop-circle"></i> Stop Recording
        </button>
    </div>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
    if (!requireAuth()) {
        throw new Error('Authentication required');
    }

    const activeTripData = localStorage.getItem('activeTrip');
    if (!activeTripData) {
        window.location.href = '/trip/dashboard';
        throw new Error('No active trip');
    }

    const activeTrip = JSON.parse(activeTripData);
    const tripId = activeTrip.tripId;
    const startTime = new Date(activeTrip.startTime);

    let map, pathPolyline, currentMarker;
    let watchId = null;
    let coordinateCount = 0;
    let pathCoordinates = [];  // For map display [lat, lon]
    let pendingCoordinates = [];   // Coordinates waiting to be sent
    let sentCoordinatesCount = 0;  // Track how many have been sent
    let sendBatchInterval = null;
    const BATCH_SIZE = 20;  // Send batch every 20 coordinates
    const BATCH_INTERVAL = 30000;  // Or every 30 seconds

    function initMap() {
        map = L.map('mapContainer').setView([45.4642, 9.1900], 15);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap contributors'
        }).addTo(map);

        pathPolyline = L.polyline([], {
            color: '#28a745',
            weight: 4,
            opacity: 0.7
        }).addTo(map);
    }

    function updateTimer() {
        const now = new Date();
        const elapsed = Math.floor((now - startTime) / 1000);
        const hours = Math.floor(elapsed / 3600);
        const minutes = Math.floor((elapsed % 3600) / 60);
        const seconds = elapsed % 60;

        document.getElementById('timer').textContent =
            `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    }

    // Calculate distance between two points using Haversine formula (returns meters)
    function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371000; // Earth's radius in meters
        const phi1 = lat1 * Math.PI / 180;
        const phi2 = lat2 * Math.PI / 180;
        const deltaPhi = (lat2 - lat1) * Math.PI / 180;
        const deltaLambda = (lon2 - lon1) * Math.PI / 180;
        
        const a = Math.sin(deltaPhi/2) * Math.sin(deltaPhi/2) +
                  Math.cos(phi1) * Math.cos(phi2) *
                  Math.sin(deltaLambda/2) * Math.sin(deltaLambda/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        
        return R * c;
    }

    // Get all coordinates (sent + pending) for statistics
    function getAllCoordinatesForStats() {
        // We need to track all coordinates for local stats display
        // This is reconstructed from pathCoordinates which has all points
        return pathCoordinates.map((coord, idx) => ({
            latitude: coord[0],
            longitude: coord[1],
            // Approximate timestamp based on trip start and index
            timestamp: new Date(startTime.getTime() + idx * 3000).toISOString()
        }));
    }

    // Calculate and display local statistics
    function updateLocalStats() {
        if (pathCoordinates.length < 2) return;
        
        let totalDistance = 0;
        let maxSpeed = 0;
        
        for (let i = 1; i < pathCoordinates.length; i++) {
            const prev = pathCoordinates[i - 1];
            const curr = pathCoordinates[i];
            
            const segmentDist = calculateDistance(prev[0], prev[1], curr[0], curr[1]);
            
            // Skip GPS noise (< 1 meter)
            if (segmentDist < 1) continue;
            
            totalDistance += segmentDist;
        }
        
        // Update UI with local calculations
        document.getElementById('distance').textContent = (totalDistance / 1000).toFixed(2);
        document.getElementById('points').textContent = pathCoordinates.length;
        
        // Show sync status
        const pending = pendingCoordinates.length;
        const synced = sentCoordinatesCount;
        if (pending > 0) {
            document.getElementById('points').textContent = `${pathCoordinates.length} (${pending} pending)`;
        }
    }

    // Send a batch of coordinates to the server
    async function sendPendingBatch() {
        if (pendingCoordinates.length === 0) return;
        
        // Take up to BATCH_SIZE coordinates
        const batchToSend = pendingCoordinates.slice(0, BATCH_SIZE);
        
        try {
            await API.trips.addCoordinatesBatch(tripId, batchToSend);
            
            // Remove sent coordinates from pending
            pendingCoordinates = pendingCoordinates.slice(batchToSend.length);
            sentCoordinatesCount += batchToSend.length;
            
            console.log(`Sent ${batchToSend.length} coordinates. Pending: ${pendingCoordinates.length}, Total sent: ${sentCoordinatesCount}`);
        } catch (error) {
            console.error('Failed to send coordinate batch:', error);
            // Keep coordinates in pending for retry
        }
    }

    // Check if we should send a batch (called periodically and on new coordinates)
    function checkAndSendBatch() {
        if (pendingCoordinates.length >= BATCH_SIZE) {
            sendPendingBatch();
        }
    }

    let gpsErrorCount = 0;
    const MAX_GPS_ERRORS = 5;
    
    // Detect iOS devices
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

    // Get user-friendly GPS error message
    function getGPSErrorMessage(error) {
        switch(error.code) {
            case 1:
                return isIOS 
                    ? 'Location access lost. Check Settings > Privacy & Security > Location Services.'
                    : 'Location access denied. Please check browser permissions.';
            case 2:
                return 'GPS signal lost. Move to an open area for better reception.';
            case 3:
                return 'GPS signal weak. Continuing to try...';
            default:
                return 'GPS error occurred. Attempting to reconnect...';
        }
    }

    function startGPSTracking() {
        if (!('geolocation' in navigator)) {
            showAlert('Geolocation not supported', 'danger');
            return;
        }

        // Use initial position from localStorage if available
        const activeTripStorage = localStorage.getItem('activeTrip');
        if (activeTripStorage) {
            const tripData = JSON.parse(activeTripStorage);
            if (tripData.initialPosition) {
                const { lat, lon } = tripData.initialPosition;
                map.setView([lat, lon], 16);
                currentMarker = L.marker([lat, lon]).addTo(map);
                pathCoordinates.push([lat, lon]);
                pathPolyline.setLatLngs(pathCoordinates);
                
                // Add initial position to pending coordinates
                pendingCoordinates.push({
                    latitude: lat,
                    longitude: lon,
                    timestamp: activeTrip.startTime,
                    elevation: null
                });
            }
        }

        // iOS-optimized geolocation options
        const geoOptions = {
            enableHighAccuracy: true,
            maximumAge: isIOS ? 5000 : 3000,
            timeout: isIOS ? 30000 : 15000
        };

        watchId = navigator.geolocation.watchPosition(
            (position) => {
                gpsErrorCount = 0;
                
                const lat = position.coords.latitude;
                const lon = position.coords.longitude;
                const elevation = position.coords.altitude;
                const accuracy = position.coords.accuracy;

                // Only add point if accuracy is reasonable (< 100 meters)
                if (accuracy && accuracy > 100) {
                    console.log('Skipping low accuracy position:', accuracy);
                    return;
                }

                // Update map display
                pathCoordinates.push([lat, lon]);
                pathPolyline.setLatLngs(pathCoordinates);

                if (currentMarker) {
                    map.removeLayer(currentMarker);
                }
                currentMarker = L.marker([lat, lon]).addTo(map);
                map.setView([lat, lon], map.getZoom());

                // Add to pending coordinates
                pendingCoordinates.push({
                    latitude: lat,
                    longitude: lon,
                    timestamp: new Date().toISOString(),
                    elevation: elevation
                });
                
                // Update local statistics
                updateLocalStats();
                
                // Check if we should send a batch
                checkAndSendBatch();
            },
            (error) => {
                console.error('GPS error:', error.code, error.message);
                gpsErrorCount++;
                
                if (gpsErrorCount <= MAX_GPS_ERRORS) {
                    if (error.code === 3) {
                        console.log('GPS timeout, waiting for signal...');
                    } else {
                        showAlert(getGPSErrorMessage(error), 'warning');
                    }
                } else {
                    showAlert('GPS connection unstable. Your trip is still being recorded when signal is available.', 'warning');
                    gpsErrorCount = 0;
                }
            },
            geoOptions
        );
    }

    document.getElementById('stopTripBtn').addEventListener('click', async () => {
        const btn = document.getElementById('stopTripBtn');
        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Saving trip...';

        // Stop GPS tracking
        if (watchId) {
            navigator.geolocation.clearWatch(watchId);
        }
        
        // Stop periodic batch sending
        if (sendBatchInterval) {
            clearInterval(sendBatchInterval);
            sendBatchInterval = null;
        }

        try {
            // Send only remaining pending coordinates (most already sent during trip)
            if (pendingCoordinates.length > 0) {
                btn.innerHTML = `<span class="spinner-border spinner-border-sm"></span> Uploading ${pendingCoordinates.length} remaining points...`;
                
                await API.trips.addCoordinatesBatch(tripId, pendingCoordinates);
                console.log(`Successfully uploaded ${pendingCoordinates.length} remaining coordinates`);
                pendingCoordinates = [];
            }

            btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Calculating statistics...';
            
            // Complete the trip
            const endTime = new Date().toISOString();
            await API.trips.complete(tripId, endTime);

            localStorage.removeItem('activeTrip');
            window.location.href = `/trip/summary/${tripId}`;
        } catch (error) {
            console.error('Error completing trip:', error);
            showAlert('Failed to complete trip: ' + error.message, 'danger');
            btn.disabled = false;
            btn.innerHTML = '<i class="bi bi-stop-circle"></i> Stop Recording';
        }
    });

    initMap();
    startGPSTracking();
    setInterval(updateTimer, 1000);
    // Update local stats every 2 seconds
    setInterval(updateLocalStats, 2000);
    // Periodic batch sending every 30 seconds
    sendBatchInterval = setInterval(sendPendingBatch, BATCH_INTERVAL);
</script>
{% endblock %}
