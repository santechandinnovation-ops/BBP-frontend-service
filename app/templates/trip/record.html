{% extends "base.html" %}

{% block title %}Recording Trip - Best Bike Paths{% endblock %}

{% block content %}
<div class="container-fluid p-3">
    <div class="text-center mb-3">
        <h2 class="text-success">Recording...</h2>
        <div id="timer" class="h4 text-muted">00:00:00</div>
    </div>

    <div class="row g-3 mb-3">
        <div class="col-4">
            <div class="card trip-stat-card">
                <div class="trip-stat-value" id="distance">0.00</div>
                <div class="trip-stat-label">km</div>
            </div>
        </div>
        <div class="col-4">
            <div class="card trip-stat-card">
                <div class="trip-stat-value" id="speed">0.0</div>
                <div class="trip-stat-label">km/h</div>
            </div>
        </div>
        <div class="col-4">
            <div class="card trip-stat-card">
                <div class="trip-stat-value" id="points">0</div>
                <div class="trip-stat-label">points</div>
            </div>
        </div>
    </div>

    <div id="mapContainer" class="map-container mb-3"></div>

    <div class="text-center">
        <button id="stopTripBtn" class="btn btn-danger btn-lg btn-lg-mobile">
            <i class="bi bi-stop-circle"></i> Stop Recording
        </button>
    </div>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
    if (!requireAuth()) {
        throw new Error('Authentication required');
    }

    const activeTripData = localStorage.getItem('activeTrip');
    if (!activeTripData) {
        window.location.href = '/trip/dashboard';
        throw new Error('No active trip');
    }

    const activeTrip = JSON.parse(activeTripData);
    const tripId = activeTrip.tripId;
    const startTime = new Date(activeTrip.startTime);

    let map, pathPolyline, currentMarker;
    let watchId = null;
    let coordinateCount = 0;
    let pathCoordinates = [];  // for showing path on map [lat, lon]
    let pendingCoordinates = [];   // coords waiting to be sent to server
    let recentCoordinates = [];    // last few coords with timestamsp for speed
    let sentCoordinatesCount = 0;  // track how many weve sent
    let sendBatchInterval = null;
    const BATCH_SIZE = 20;  // send batch every 20 coords
    const BATCH_INTERVAL = 30000;  // or every 30 secs
    const MAX_RECENT_FOR_SPEED = 5;  // keep last 5 points for speed calc

    function initMap() {
        map = L.map('mapContainer').setView([45.4642, 9.1900], 15);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap contributors'
        }).addTo(map);

        pathPolyline = L.polyline([], {
            color: '#28a745',
            weight: 4,
            opacity: 0.7
        }).addTo(map);
    }

    function updateTimer() {
        const now = new Date();
        const elapsed = Math.floor((now - startTime) / 1000);
        const hours = Math.floor(elapsed / 3600);
        const minutes = Math.floor((elapsed % 3600) / 60);
        const seconds = elapsed % 60;

        document.getElementById('timer').textContent =
            `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    }

    // calc distance btwn two points w haversine formula (returns meters)
    function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371000; // earths radius in meters
        const phi1 = lat1 * Math.PI / 180;
        const phi2 = lat2 * Math.PI / 180;
        const deltaPhi = (lat2 - lat1) * Math.PI / 180;
        const deltaLambda = (lon2 - lon1) * Math.PI / 180;
        
        const a = Math.sin(deltaPhi/2) * Math.sin(deltaPhi/2) +
                  Math.cos(phi1) * Math.cos(phi2) *
                  Math.sin(deltaLambda/2) * Math.sin(deltaLambda/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        
        return R * c;
    }

    // get all coords (sent + pending) for stats
    function getAllCoordinatesForStats() {
        // we need all coords for local stats display
        // reconstruct from pathCoordinates wich has all points
        return pathCoordinates.map((coord, idx) => ({
            latitude: coord[0],
            longitude: coord[1],
            // aproximate timestamp based on trip start and index
            timestamp: new Date(startTime.getTime() + idx * 3000).toISOString()
        }));
    }

    // calc and display local statistics
    function updateLocalStats() {
        if (pathCoordinates.length < 2) return;
        
        let totalDistance = 0;
        let currentSpeed = 0;
        
        for (let i = 1; i < pathCoordinates.length; i++) {
            const prev = pathCoordinates[i - 1];
            const curr = pathCoordinates[i];
            
            const segmentDist = calculateDistance(prev[0], prev[1], curr[0], curr[1]);
            
            // skip gps noise (less than 1 meter)
            if (segmentDist < 1) continue;
            
            totalDistance += segmentDist;
        }
        
        // calc current speed from recent coords (w actual timestamps)
        if (recentCoordinates.length >= 2) {
            let recentDist = 0;
            for (let i = 1; i < recentCoordinates.length; i++) {
                const prev = recentCoordinates[i - 1];
                const curr = recentCoordinates[i];
                const d = calculateDistance(prev.lat, prev.lon, curr.lat, curr.lon);
                if (d >= 1) recentDist += d;
            }
            
            const firstTime = recentCoordinates[0].time;
            const lastTime = recentCoordinates[recentCoordinates.length - 1].time;
            const timeDiffSeconds = (lastTime - firstTime) / 1000;
            
            if (timeDiffSeconds > 0) {
                currentSpeed = recentDist / timeDiffSeconds; // meters per second
            }
        }
        
        // update UI with local calcs
        document.getElementById('distance').textContent = (totalDistance / 1000).toFixed(2);
        document.getElementById('speed').textContent = (currentSpeed * 3.6).toFixed(1); // m/s to km/h
        document.getElementById('points').textContent = pathCoordinates.length;
    }

    // flag to prevent concurrent batch sends
    let isSendingBatch = false;

    // Send a batch of coordinates to the server
    async function sendPendingBatch() {
        // Prevent concurrent sends that would cause duplicates
        if (isSendingBatch || pendingCoordinates.length === 0) return;
        
        isSendingBatch = true;
        
        // Take up to BATCH_SIZE coordinates and REMOVE them from pending immediately
        const batchToSend = pendingCoordinates.splice(0, BATCH_SIZE);
        
        try {
            await API.trips.addCoordinatesBatch(tripId, batchToSend);
            sentCoordinatesCount += batchToSend.length;
            
            console.log(`Sent ${batchToSend.length} coordinates. Pending: ${pendingCoordinates.length}, Total sent: ${sentCoordinatesCount}`);
        } catch (error) {
            console.error('Failed to send coordinate batch:', error);
            // Put coordinates back at the beginning of pending for retry
            pendingCoordinates.unshift(...batchToSend);
        } finally {
            isSendingBatch = false;
        }
    }

    // Check if we should send a batch (called periodically and on new coordinates)
    function checkAndSendBatch() {
        if (pendingCoordinates.length >= BATCH_SIZE && !isSendingBatch) {
            sendPendingBatch();
        }
    }

    let gpsErrorCount = 0;
    const MAX_GPS_ERRORS = 5;
    
    // Detect iOS devices
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    
    // Fallback polling interval for when watchPosition doesn't fire
    let gpsPollingInterval = null;
    let lastPositionTime = 0;
    const GPS_POLLING_INTERVAL = 3000; // Poll every 3 seconds as fallback
    const POSITION_STALE_THRESHOLD = 5000; // Consider position stale after 5 seconds

    // Get user-friendly GPS error message
    function getGPSErrorMessage(error) {
        switch(error.code) {
            case 1:
                return isIOS 
                    ? 'Location access lost. Check Settings > Privacy & Security > Location Services.'
                    : 'Location access denied. Please check browser permissions.';
            case 2:
                return 'GPS signal lost. Move to an open area for better reception.';
            case 3:
                return 'GPS signal weak. Continuing to try...';
            default:
                return 'GPS error occurred. Attempting to reconnect...';
        }
    }
    
    // Process a new GPS position (shared between watchPosition and polling)
    function processGPSPosition(position) {
        gpsErrorCount = 0;
        lastPositionTime = Date.now();
        
        const lat = position.coords.latitude;
        const lon = position.coords.longitude;
        const elevation = position.coords.altitude;
        const accuracy = position.coords.accuracy;

        // Only add point if accuracy is reasonable (< 100 meters)
        if (accuracy && accuracy > 100) {
            console.log('Skipping low accuracy position:', accuracy);
            return;
        }
        
        // Skip if this is essentially the same position as the last one (within 2 meters)
        if (pathCoordinates.length > 0) {
            const lastCoord = pathCoordinates[pathCoordinates.length - 1];
            const distFromLast = calculateDistance(lastCoord[0], lastCoord[1], lat, lon);
            if (distFromLast < 2) {
                console.log('Skipping duplicate position, distance:', distFromLast.toFixed(2), 'm');
                return;
            }
        }

        // Update map display
        pathCoordinates.push([lat, lon]);
        pathPolyline.setLatLngs(pathCoordinates);

        if (currentMarker) {
            map.removeLayer(currentMarker);
        }
        currentMarker = L.marker([lat, lon]).addTo(map);
        map.setView([lat, lon], map.getZoom());

        // Add to pending coordinates
        pendingCoordinates.push({
            latitude: lat,
            longitude: lon,
            timestamp: new Date().toISOString(),
            elevation: elevation
        });
        
        // Add to recent coordinates for speed calculation (keep only last N)
        recentCoordinates.push({
            lat: lat,
            lon: lon,
            time: Date.now()
        });
        if (recentCoordinates.length > MAX_RECENT_FOR_SPEED) {
            recentCoordinates.shift();
        }
        
        // Update local statistics
        updateLocalStats();
        
        // Check if we should send a batch
        checkAndSendBatch();
    }
    
    // Fallback polling function - used when watchPosition doesn't fire
    function pollGPSPosition() {
        const timeSinceLastPosition = Date.now() - lastPositionTime;
        
        // Only poll if we haven't received a position recently
        if (timeSinceLastPosition > POSITION_STALE_THRESHOLD) {
            console.log('watchPosition stale, polling for position...');
            
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    console.log('Got position from polling');
                    processGPSPosition(position);
                },
                (error) => {
                    console.log('Polling GPS error:', error.code);
                },
                {
                    enableHighAccuracy: true,
                    maximumAge: 0, // Force fresh position
                    timeout: isIOS ? 15000 : 10000
                }
            );
        }
    }

    function startGPSTracking() {
        if (!('geolocation' in navigator)) {
            showAlert('Geolocation not supported', 'danger');
            return;
        }

        // Use initial position from localStorage if available
        const activeTripStorage = localStorage.getItem('activeTrip');
        if (activeTripStorage) {
            const tripData = JSON.parse(activeTripStorage);
            if (tripData.initialPosition) {
                const { lat, lon } = tripData.initialPosition;
                map.setView([lat, lon], 16);
                currentMarker = L.marker([lat, lon]).addTo(map);
                pathCoordinates.push([lat, lon]);
                pathPolyline.setLatLngs(pathCoordinates);
                
                // Add initial position to pending coordinates
                pendingCoordinates.push({
                    latitude: lat,
                    longitude: lon,
                    timestamp: activeTrip.startTime,
                    elevation: null
                });
                
                // Add to recent coordinates for speed calculation
                recentCoordinates.push({
                    lat: lat,
                    lon: lon,
                    time: new Date(activeTrip.startTime).getTime()
                });
                
                // Mark that we have a position
                lastPositionTime = Date.now();
                
                // Update stats with initial point
                updateLocalStats();
            }
        }

        // iOS-optimized geolocation options
        const geoOptions = {
            enableHighAccuracy: true,
            maximumAge: isIOS ? 5000 : 3000,
            timeout: isIOS ? 30000 : 15000
        };

        watchId = navigator.geolocation.watchPosition(
            (position) => {
                processGPSPosition(position);
            },
            (error) => {
                console.error('GPS error:', error.code, error.message);
                gpsErrorCount++;
                
                if (gpsErrorCount <= MAX_GPS_ERRORS) {
                    if (error.code === 3) {
                        console.log('GPS timeout, waiting for signal...');
                    } else {
                        showAlert(getGPSErrorMessage(error), 'warning');
                    }
                } else {
                    showAlert('GPS connection unstable. Your trip is still being recorded when signal is available.', 'warning');
                    gpsErrorCount = 0;
                }
            },
            geoOptions
        );
        
        // Start fallback polling to ensure we get positions even if watchPosition is unreliable
        gpsPollingInterval = setInterval(pollGPSPosition, GPS_POLLING_INTERVAL);
    }

    document.getElementById('stopTripBtn').addEventListener('click', async () => {
        const btn = document.getElementById('stopTripBtn');
        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Saving trip...';

        // Stop GPS tracking
        if (watchId) {
            navigator.geolocation.clearWatch(watchId);
        }
        
        // Stop GPS polling fallback
        if (gpsPollingInterval) {
            clearInterval(gpsPollingInterval);
            gpsPollingInterval = null;
        }
        
        // Stop periodic batch sending
        if (sendBatchInterval) {
            clearInterval(sendBatchInterval);
            sendBatchInterval = null;
        }

        try {
            // Wait for any ongoing batch send to complete
            while (isSendingBatch) {
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            // Send only remaining pending coordinates (most already sent during trip)
            if (pendingCoordinates.length > 0) {
                btn.innerHTML = `<span class="spinner-border spinner-border-sm"></span> Uploading ${pendingCoordinates.length} remaining points...`;
                
                // Send directly without using sendPendingBatch to avoid flag issues
                await API.trips.addCoordinatesBatch(tripId, pendingCoordinates);
                console.log(`Successfully uploaded ${pendingCoordinates.length} remaining coordinates`);
                pendingCoordinates = [];
            }

            btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Calculating statistics...';
            
            // Complete the trip
            const endTime = new Date().toISOString();
            await API.trips.complete(tripId, endTime);

            localStorage.removeItem('activeTrip');
            window.location.href = `/trip/summary/${tripId}`;
        } catch (error) {
            console.error('Error completing trip:', error);
            showAlert('Failed to complete trip: ' + error.message, 'danger');
            btn.disabled = false;
            btn.innerHTML = '<i class="bi bi-stop-circle"></i> Stop Recording';
        }
    });

    initMap();
    startGPSTracking();
    setInterval(updateTimer, 1000);
    // Update local stats every 2 seconds
    setInterval(updateLocalStats, 2000);
    // Periodic batch sending every 30 seconds
    sendBatchInterval = setInterval(sendPendingBatch, BATCH_INTERVAL);
</script>
{% endblock %}
