{% extends "base.html" %}

{% block title %}Search Routes - Best Bike Paths{% endblock %}

{% block extra_css %}
<style>
    .location-card {
        border: 2px solid #dee2e6;
        border-radius: 12px;
        transition: all 0.3s;
    }
    .location-card.active {
        border-color: #0d6efd;
        box-shadow: 0 0 0 3px rgba(13, 110, 253, 0.25);
    }
    .location-card.set {
        border-color: #28a745;
        background-color: #f8fff9;
    }
    .location-card .card-header {
        background: transparent;
        border-bottom: 1px solid #dee2e6;
    }
    .location-input-group {
        display: flex;
        gap: 10px;
        align-items: center;
    }
    .location-input-group .form-control {
        flex: 1;
    }
    .method-toggle {
        display: flex;
        gap: 5px;
        margin-bottom: 15px;
    }
    .method-toggle .btn {
        flex: 1;
    }
    .coordinates-display {
        font-family: monospace;
        font-size: 0.85rem;
        color: #6c757d;
        margin-top: 5px;
    }
    .search-suggestions {
        position: absolute;
        z-index: 1050;
        width: 100%;
        max-height: 200px;
        overflow-y: auto;
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    .search-suggestions .suggestion-item {
        padding: 10px 15px;
        cursor: pointer;
        border-bottom: 1px solid #f0f0f0;
    }
    .search-suggestions .suggestion-item:hover {
        background-color: #f8f9fa;
    }
    .search-suggestions .suggestion-item:last-child {
        border-bottom: none;
    }
    .map-instruction {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 1000;
        background: rgba(13, 110, 253, 0.95);
        color: white;
        padding: 10px 20px;
        border-radius: 25px;
        font-weight: 500;
        display: none;
    }
    .map-instruction.active {
        display: block;
    }
    #mapContainer {
        position: relative;
    }
    .location-marker-origin {
        color: #28a745;
        font-size: 28px;
    }
    .location-marker-dest {
        color: #dc3545;
        font-size: 28px;
    }
    .obstacle-marker {
        background: transparent;
        border: none;
        font-size: 20px;
    }
    .text-orange {
        color: #fd7e14 !important;
    }
    .route-card {
        transition: all 0.2s ease;
    }
    .route-card:hover {
        background-color: #f8f9fa;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    .map-loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 255, 0.8);
        z-index: 1000;
        display: none;
        justify-content: center;
        align-items: center;
        flex-direction: column;
    }
    .map-loading-overlay.active {
        display: flex;
    }
    .map-loading-overlay .spinner-border {
        width: 3rem;
        height: 3rem;
    }
    .map-loading-overlay .loading-text {
        margin-top: 10px;
        font-weight: 500;
        color: #198754;
    }
    .route-card.selected {
        transform: scale(1.02);
    }
    .show-route-btn {
        transition: all 0.2s ease;
    }
    .show-route-btn:hover {
        transform: scale(1.05);
    }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid p-3">
    <h2 class="mb-4"><i class="bi bi-search me-2"></i>Search Bike Routes</h2>

    <div class="row mb-3">
        <!-- Origin Card -->
        <div class="col-md-6 mb-3 mb-md-0">
            <div class="card location-card" id="originCard">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <span><i class="bi bi-geo-alt-fill text-success me-2"></i><strong>Origin</strong></span>
                    <button type="button" class="btn btn-sm btn-outline-secondary" id="clearOrigin" style="display: none;">
                        <i class="bi bi-x"></i> Clear
                    </button>
                </div>
                <div class="card-body">
                    <div class="method-toggle">
                        <button type="button" class="btn btn-outline-primary active" data-method="search" data-target="origin">
                            <i class="bi bi-search"></i> Search
                        </button>
                        <button type="button" class="btn btn-outline-primary" data-method="map" data-target="origin">
                            <i class="bi bi-cursor"></i> Click Map
                        </button>
                        <button type="button" class="btn btn-outline-primary" data-method="gps" data-target="origin">
                            <i class="bi bi-crosshair"></i> GPS
                        </button>
                    </div>
                    <div class="position-relative">
                        <input type="text" class="form-control" id="originSearch" placeholder="Search address, city, place...">
                        <div class="search-suggestions" id="originSuggestions" style="display: none;"></div>
                    </div>
                    <div class="coordinates-display" id="originCoords">No location set</div>
                    <input type="hidden" id="originLat">
                    <input type="hidden" id="originLon">
                </div>
            </div>
        </div>

        <!-- Destination Card -->
        <div class="col-md-6">
            <div class="card location-card" id="destCard">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <span><i class="bi bi-flag-fill text-danger me-2"></i><strong>Destination</strong></span>
                    <button type="button" class="btn btn-sm btn-outline-secondary" id="clearDest" style="display: none;">
                        <i class="bi bi-x"></i> Clear
                    </button>
                </div>
                <div class="card-body">
                    <div class="method-toggle">
                        <button type="button" class="btn btn-outline-primary active" data-method="search" data-target="dest">
                            <i class="bi bi-search"></i> Search
                        </button>
                        <button type="button" class="btn btn-outline-primary" data-method="map" data-target="dest">
                            <i class="bi bi-cursor"></i> Click Map
                        </button>
                    </div>
                    <div class="position-relative">
                        <input type="text" class="form-control" id="destSearch" placeholder="Search address, city, place...">
                        <div class="search-suggestions" id="destSuggestions" style="display: none;"></div>
                    </div>
                    <div class="coordinates-display" id="destCoords">No location set</div>
                    <input type="hidden" id="destLat">
                    <input type="hidden" id="destLon">
                </div>
            </div>
        </div>
    </div>

    <!-- Search Button -->
    <div class="text-center mb-3">
        <button type="button" class="btn btn-success btn-lg px-5" id="searchBtn" disabled>
            <i class="bi bi-signpost-2 me-2"></i> Find Routes
        </button>
    </div>

    <!-- Map -->
    <div id="mapContainer" class="map-container mb-3">
        <div class="map-instruction" id="mapInstruction">
            <i class="bi bi-cursor me-2"></i>
            <span id="mapInstructionText">Click on the map to set origin</span>
        </div>
        <div class="map-loading-overlay" id="mapLoadingOverlay">
            <div class="spinner-border text-success" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <div class="loading-text">Loading route...</div>
        </div>
    </div>

    <!-- Results -->
    <div id="resultsContainer"></div>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
    let map;
    let markersLayer;
    let routesLayer;
    let originMarker = null;
    let destMarker = null;
    let activeMapSelection = null; // 'origin' or 'dest'
    let searchTimeout = null;

    // Initialize map
    function initMap() {
        map = L.map('mapContainer').setView([45.4642, 9.1900], 13);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap contributors'
        }).addTo(map);
        markersLayer = L.layerGroup().addTo(map);
        routesLayer = L.layerGroup().addTo(map);

        map.on('click', handleMapClick);
    }

    // Handle map click for location selection
    function handleMapClick(e) {
        if (!activeMapSelection) return;

        const lat = e.latlng.lat;
        const lng = e.latlng.lng;

        setLocation(activeMapSelection, lat, lng, 'Map selection');
        
        // Reverse geocode to get address
        reverseGeocode(lat, lng, activeMapSelection);
        
        // Exit map selection mode
        exitMapSelectionMode();
    }

    // Reverse geocode coordinates to address
    async function reverseGeocode(lat, lng, target) {
        try {
            const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1`);
            const data = await response.json();
            
            if (data && data.display_name) {
                const searchInput = document.getElementById(`${target}Search`);
                searchInput.value = data.display_name.split(',').slice(0, 3).join(',');
            }
        } catch (error) {
            console.error('Reverse geocode error:', error);
        }
    }

    // Search for locations using Nominatim
    async function searchLocation(query, target) {
        if (query.length < 3) {
            hideSuggestions(target);
            return;
        }

        try {
            const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=5&addressdetails=1`);
            const data = await response.json();
            
            showSuggestions(data, target);
        } catch (error) {
            console.error('Search error:', error);
            hideSuggestions(target);
        }
    }

    // Show suggestions dropdown
    function showSuggestions(results, target) {
        const container = document.getElementById(`${target}Suggestions`);
        
        if (results.length === 0) {
            container.innerHTML = '<div class="suggestion-item text-muted">No results found</div>';
            container.style.display = 'block';
            return;
        }

        let html = '';
        results.forEach(result => {
            const displayName = result.display_name.split(',').slice(0, 3).join(',');
            html += `
                <div class="suggestion-item" data-lat="${result.lat}" data-lon="${result.lon}" data-name="${displayName}" data-target="${target}">
                    <i class="bi bi-geo-alt me-2"></i>${displayName}
                </div>
            `;
        });

        container.innerHTML = html;
        container.style.display = 'block';

        // Add click handlers
        container.querySelectorAll('.suggestion-item').forEach(item => {
            item.addEventListener('click', () => {
                const lat = parseFloat(item.dataset.lat);
                const lon = parseFloat(item.dataset.lon);
                const name = item.dataset.name;
                const itemTarget = item.dataset.target;

                setLocation(itemTarget, lat, lon, name);
                document.getElementById(`${itemTarget}Search`).value = name;
                hideSuggestions(itemTarget);
            });
        });
    }

    function hideSuggestions(target) {
        document.getElementById(`${target}Suggestions`).style.display = 'none';
    }

    // Set location (origin or destination)
    function setLocation(target, lat, lng, name) {
        document.getElementById(`${target}Lat`).value = lat;
        document.getElementById(`${target}Lon`).value = lng;
        document.getElementById(`${target}Coords`).textContent = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;

        // Update card styling
        const card = document.getElementById(`${target}Card`);
        card.classList.remove('active');
        card.classList.add('set');
        document.getElementById(`clear${target.charAt(0).toUpperCase() + target.slice(1)}`).style.display = 'block';

        // Add/update marker
        if (target === 'origin') {
            if (originMarker) map.removeLayer(originMarker);
            originMarker = L.marker([lat, lng], {
                icon: L.divIcon({
                    className: 'location-marker-origin',
                    html: '<i class="bi bi-geo-alt-fill"></i>',
                    iconSize: [28, 28],
                    iconAnchor: [14, 28]
                })
            }).addTo(map).bindPopup(`<strong>Origin</strong><br>${name}`);
        } else {
            if (destMarker) map.removeLayer(destMarker);
            destMarker = L.marker([lat, lng], {
                icon: L.divIcon({
                    className: 'location-marker-dest',
                    html: '<i class="bi bi-flag-fill"></i>',
                    iconSize: [28, 28],
                    iconAnchor: [14, 28]
                })
            }).addTo(map).bindPopup(`<strong>Destination</strong><br>${name}`);
        }

        updateSearchButton();
        fitMapToBounds();
    }

    // Clear location
    function clearLocation(target) {
        document.getElementById(`${target}Lat`).value = '';
        document.getElementById(`${target}Lon`).value = '';
        document.getElementById(`${target}Coords`).textContent = 'No location set';
        document.getElementById(`${target}Search`).value = '';

        const card = document.getElementById(`${target}Card`);
        card.classList.remove('set', 'active');
        document.getElementById(`clear${target.charAt(0).toUpperCase() + target.slice(1)}`).style.display = 'none';

        if (target === 'origin' && originMarker) {
            map.removeLayer(originMarker);
            originMarker = null;
        } else if (target === 'dest' && destMarker) {
            map.removeLayer(destMarker);
            destMarker = null;
        }

        updateSearchButton();
    }

    // Enter map selection mode
    function enterMapSelectionMode(target) {
        activeMapSelection = target;
        
        const instruction = document.getElementById('mapInstruction');
        const text = target === 'origin' ? 'Click on the map to set ORIGIN' : 'Click on the map to set DESTINATION';
        document.getElementById('mapInstructionText').textContent = text;
        instruction.classList.add('active');

        document.getElementById(`${target}Card`).classList.add('active');
        
        // Scroll to map
        document.getElementById('mapContainer').scrollIntoView({ behavior: 'smooth', block: 'center' });
    }

    // Exit map selection mode
    function exitMapSelectionMode() {
        activeMapSelection = null;
        document.getElementById('mapInstruction').classList.remove('active');
        document.getElementById('originCard').classList.remove('active');
        document.getElementById('destCard').classList.remove('active');
    }

    // Use GPS for current location
    function useGPS(target) {
        if (!('geolocation' in navigator)) {
            showAlert('Geolocation is not supported by your browser', 'danger');
            return;
        }

        showAlert('Getting your location...', 'info');

        navigator.geolocation.getCurrentPosition(
            (position) => {
                const lat = position.coords.latitude;
                const lng = position.coords.longitude;
                setLocation(target, lat, lng, 'Current location');
                reverseGeocode(lat, lng, target);
                showAlert('Location set to your current position', 'success');
            },
            (error) => {
                showAlert('Could not get your location: ' + error.message, 'danger');
            },
            { enableHighAccuracy: true, timeout: 10000 }
        );
    }

    // Update search button state
    function updateSearchButton() {
        const originLat = document.getElementById('originLat').value;
        const destLat = document.getElementById('destLat').value;
        const btn = document.getElementById('searchBtn');
        
        btn.disabled = !(originLat && destLat);
    }

    // Fit map to show both markers
    function fitMapToBounds() {
        const bounds = [];
        if (originMarker) bounds.push(originMarker.getLatLng());
        if (destMarker) bounds.push(destMarker.getLatLng());

        if (bounds.length === 2) {
            map.fitBounds(L.latLngBounds(bounds), { padding: [50, 50] });
        } else if (bounds.length === 1) {
            map.setView(bounds[0], 14);
        }
    }

    // Search routes
    async function searchRoutes() {
        const originLat = parseFloat(document.getElementById('originLat').value);
        const originLon = parseFloat(document.getElementById('originLon').value);
        const destLat = parseFloat(document.getElementById('destLat').value);
        const destLon = parseFloat(document.getElementById('destLon').value);

        if (isNaN(originLat) || isNaN(originLon) || isNaN(destLat) || isNaN(destLon)) {
            showAlert('Please set both origin and destination', 'warning');
            return;
        }

        const btn = document.getElementById('searchBtn');
        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Searching...';

        showLoading('resultsContainer');

        try {
            const data = await API.paths.search({
                originLat: originLat,
                originLon: originLon,
                destLat: destLat,
                destLon: destLon
            });

            displayRoutes(data.routes);
        } catch (error) {
            document.getElementById('resultsContainer').innerHTML = `
                <div class="alert alert-danger">
                    <i class="bi bi-exclamation-triangle me-2"></i>
                    Failed to search routes: ${error.message}
                </div>
            `;
        } finally {
            btn.disabled = false;
            btn.innerHTML = '<i class="bi bi-signpost-2 me-2"></i> Find Routes';
        }
    }

    // Store found routes for click-to-display
    let foundRoutes = [];
    let selectedRouteIndex = null;

    // Display routes as a list (without showing on map initially)
    function displayRoutes(routes) {
        routesLayer.clearLayers();
        foundRoutes = routes || [];
        selectedRouteIndex = null;

        if (!routes || routes.length === 0) {
            document.getElementById('resultsContainer').innerHTML = `
                <div class="alert alert-info">
                    <i class="bi bi-info-circle me-2"></i>
                    No routes found for this search. Try adjusting your origin or destination.
                </div>
            `;
            return;
        }

        const colors = ['#0d6efd', '#198754', '#6f42c1', '#fd7e14'];

        let html = `
            <h4 class="mb-3"><i class="bi bi-signpost-2 me-2"></i>Found ${routes.length} route(s)</h4>
            <p class="text-muted small mb-3">
                <i class="bi bi-hand-index me-2"></i>Click on a route to view it on the map
            </p>
        `;

        routes.forEach((route, index) => {
            const color = colors[index % colors.length];
            
            // Calculate total obstacles
            const totalObstacles = route.segments.reduce((acc, seg) => acc + (seg.obstacles?.length || 0), 0);
            
            // Calculate average status
            const statusCounts = { OPTIMAL: 0, MEDIUM: 0, SUFFICIENT: 0, REQUIRES_MAINTENANCE: 0 };
            route.segments.forEach(seg => {
                if (seg.status && statusCounts.hasOwnProperty(seg.status)) {
                    statusCounts[seg.status]++;
                }
            });
            const dominantStatus = Object.entries(statusCounts).sort((a, b) => b[1] - a[1])[0][0];
            const statusColors = {
                'OPTIMAL': '#28a745',
                'MEDIUM': '#ffc107', 
                'SUFFICIENT': '#fd7e14',
                'REQUIRES_MAINTENANCE': '#dc3545'
            };
            const statusLabels = {
                'OPTIMAL': 'Excellent',
                'MEDIUM': 'Good', 
                'SUFFICIENT': 'Fair',
                'REQUIRES_MAINTENANCE': 'Poor'
            };

            html += `
                <div class="card mb-3 route-card" data-route-index="${index}" style="border-left: 4px solid ${color}; cursor: pointer; transition: all 0.2s ease;">
                    <div class="card-body">
                        <div class="d-flex justify-content-between align-items-start">
                            <h5 class="card-title mb-2">
                                <span class="badge" style="background-color: ${color};">Route ${index + 1}</span>
                                ${index === 0 ? '<span class="badge bg-success ms-2"><i class="bi bi-star-fill me-1"></i>Best</span>' : ''}
                            </h5>
                            <div class="d-flex gap-2">
                                <button class="btn btn-sm btn-primary show-route-btn" data-route-index="${index}" title="Show on map">
                                    <i class="bi bi-map me-1"></i>Show
                                </button>
                                <a href="/search/route/${route.routeId}" class="btn btn-sm btn-outline-primary">
                                    <i class="bi bi-eye me-1"></i>Details
                                </a>
                            </div>
                        </div>
                        <div class="row g-2 mt-2">
                            <div class="col-6 col-md-3">
                                <div class="text-muted small">Distance</div>
                                <strong>${formatDistanceKm(route.totalDistance)}</strong>
                            </div>
                            <div class="col-6 col-md-3">
                                <div class="text-muted small">Quality Score</div>
                                <strong class="${route.score >= 700 ? 'text-success' : route.score >= 400 ? 'text-warning' : 'text-danger'}">${route.score.toFixed(0)}</strong>
                            </div>
                            <div class="col-6 col-md-3">
                                <div class="text-muted small">Condition</div>
                                <strong style="color: ${statusColors[dominantStatus]}">${statusLabels[dominantStatus]}</strong>
                            </div>
                            <div class="col-6 col-md-3">
                                <div class="text-muted small">Obstacles</div>
                                <strong class="${totalObstacles > 0 ? 'text-warning' : 'text-success'}">${totalObstacles > 0 ? totalObstacles : 'None'}</strong>
                            </div>
                        </div>
                        <div class="mt-2">
                            <small class="text-muted">
                                <i class="bi bi-signpost-split me-1"></i>${route.segments.length} segments
                            </small>
                        </div>
                    </div>
                </div>
            `;
        });

        document.getElementById('resultsContainer').innerHTML = html;

        // Add click handlers to route cards
        document.querySelectorAll('.route-card').forEach(card => {
            card.addEventListener('click', function(e) {
                // Don't trigger if clicking on a button or link
                if (e.target.closest('a') || e.target.closest('.show-route-btn')) return;
                
                const routeIndex = parseInt(this.dataset.routeIndex);
                showRouteOnMap(routeIndex);
            });
        });

        // Add click handlers to "Show" buttons
        document.querySelectorAll('.show-route-btn').forEach(btn => {
            btn.addEventListener('click', function(e) {
                e.stopPropagation();
                const routeIndex = parseInt(this.dataset.routeIndex);
                showRouteOnMap(routeIndex);
            });
        });
    }

    // Show a specific route on the map
    async function showRouteOnMap(routeIndex) {
        if (routeIndex < 0 || routeIndex >= foundRoutes.length) return;

        // Show loading overlay
        const loadingOverlay = document.getElementById('mapLoadingOverlay');
        loadingOverlay.classList.add('active');

        const route = foundRoutes[routeIndex];
        const colors = ['#0d6efd', '#198754', '#6f42c1', '#fd7e14'];
        const color = colors[routeIndex % colors.length];

        // Clear previous route display
        routesLayer.clearLayers();
        selectedRouteIndex = routeIndex;

        // Update card styling to show selection
        document.querySelectorAll('.route-card').forEach((card, idx) => {
            if (idx === routeIndex) {
                card.style.boxShadow = '0 0 0 3px ' + color;
                card.style.transform = 'scale(1.02)';
            } else {
                card.style.boxShadow = 'none';
                card.style.transform = 'scale(1)';
            }
        });

        // Draw route segments with status colors
        const statusColors = {
            'OPTIMAL': '#28a745',
            'MEDIUM': '#ffc107', 
            'SUFFICIENT': '#fd7e14',
            'REQUIRES_MAINTENANCE': '#dc3545'
        };

        // Fetch all OSRM routes in parallel to reduce lag
        const routePromises = route.segments.map(async (segment) => {
            if (segment.routeGeometry && segment.routeGeometry.length > 0) {
                // Use pre-saved geometry if available
                return segment.routeGeometry.map(c => [c[1], c[0]]); // Convert [lon, lat] to [lat, lon]
            } else {
                // Fetch road-projected route from OSRM for visualization
                const roadRoute = await getRouteOnRoad(
                    segment.startLatitude, segment.startLongitude,
                    segment.endLatitude, segment.endLongitude
                );
                
                if (roadRoute && roadRoute.length > 0) {
                    return roadRoute; // Already in [lat, lon] format
                } else {
                    // Fallback to straight line if OSRM fails
                    return [
                        [segment.startLatitude, segment.startLongitude],
                        [segment.endLatitude, segment.endLongitude]
                    ];
                }
            }
        });

        // Wait for all routes to be fetched in parallel
        const allCoords = await Promise.all(routePromises);

        // Now draw all segments with their fetched coordinates
        route.segments.forEach((segment, index) => {
            const segmentColor = statusColors[segment.status] || color;
            const coords = allCoords[index];

            L.polyline(coords, {
                color: segmentColor,
                weight: 6,
                opacity: 0.85
            }).addTo(routesLayer)
            .bindPopup(`
                <strong>Segment</strong><br>
                Status: ${segment.status}<br>
                Distance: ${segment.distance ? formatDistanceKm(segment.distance / 1000) : 'N/A'}
            `);

            // Draw obstacles for this segment
            if (segment.obstacles && segment.obstacles.length > 0) {
                segment.obstacles.forEach(obstacle => {
                    L.marker([obstacle.latitude, obstacle.longitude], {
                        icon: L.divIcon({
                            className: 'obstacle-marker',
                            html: `<span style="font-size: 24px; filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.5));">${getObstacleIcon(obstacle.type)}</span>`,
                            iconSize: [24, 24],
                            iconAnchor: [12, 12]
                        })
                    }).addTo(routesLayer)
                    .bindPopup(`
                        <strong>${getObstacleLabel(obstacle.type)}</strong><br>
                        Severity: <span class="${getSeverityClass(obstacle.severity)}">${obstacle.severity}</span>
                    `);
                });
            }
        });

        // Fit map to show the route
        if (routesLayer.getLayers().length > 0) {
            const allBounds = L.featureGroup([markersLayer, routesLayer]).getBounds();
            map.fitBounds(allBounds, { padding: [50, 50] });
        }

        // Hide loading overlay
        loadingOverlay.classList.remove('active');

        // Scroll to map
        document.getElementById('mapContainer').scrollIntoView({ behavior: 'smooth', block: 'center' });
    }

    // Get obstacle label
    function getObstacleLabel(type) {
        const labels = {
            'POTHOLE': 'Pothole',
            'ROUGH_SURFACE': 'Rough Surface',
            'DEBRIS': 'Debris',
            'CONSTRUCTION': 'Construction',
            'OTHER': 'Other Obstacle'
        };
        return labels[type] || type;
    }

    // Get severity CSS class
    function getSeverityClass(severity) {
        const classes = {
            'MINOR': 'text-warning',
            'MODERATE': 'text-orange',
            'SEVERE': 'text-danger'
        };
        return classes[severity] || '';
    }

    // Decode polyline from OSRM (uses Google polyline encoding)
    function decodePolyline(encoded) {
        let points = [];
        let index = 0, lat = 0, lng = 0;

        while (index < encoded.length) {
            let b, shift = 0, result = 0;
            do {
                b = encoded.charCodeAt(index++) - 63;
                result |= (b & 0x1f) << shift;
                shift += 5;
            } while (b >= 0x20);
            let dlat = ((result & 1) ? ~(result >> 1) : (result >> 1));
            lat += dlat;

            shift = 0;
            result = 0;
            do {
                b = encoded.charCodeAt(index++) - 63;
                result |= (b & 0x1f) << shift;
                shift += 5;
            } while (b >= 0x20);
            let dlng = ((result & 1) ? ~(result >> 1) : (result >> 1));
            lng += dlng;

            points.push([lat / 1e5, lng / 1e5]);
        }
        return points;
    }

    // Get route from OSRM that follows actual roads (for visualization only)
    async function getRouteOnRoad(startLat, startLng, endLat, endLng) {
        try {
            const url = `https://router.project-osrm.org/route/v1/bike/${startLng},${startLat};${endLng},${endLat}?overview=full&geometries=polyline`;
            
            const response = await fetch(url);
            const data = await response.json();
            
            if (data.code === 'Ok' && data.routes && data.routes.length > 0) {
                return decodePolyline(data.routes[0].geometry);
            }
            return null;
        } catch (error) {
            console.error('Error fetching route from OSRM:', error);
            return null;
        }
    }

    // Get obstacle icon
    function getObstacleIcon(type) {
        const icons = {
            'POTHOLE': 'ðŸ•³ï¸',
            'ROUGH_SURFACE': 'ðŸª¨',
            'DEBRIS': 'ðŸ—‘ï¸',
            'CONSTRUCTION': 'ðŸš§',
            'OTHER': 'âš ï¸'
        };
        return icons[type] || 'âš ï¸';
    }

    // Event listeners
    document.querySelectorAll('.method-toggle .btn').forEach(btn => {
        btn.addEventListener('click', function() {
            const method = this.dataset.method;
            const target = this.dataset.target;

            // Update active button
            this.closest('.method-toggle').querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
            this.classList.add('active');

            // Handle method
            if (method === 'map') {
                enterMapSelectionMode(target);
            } else if (method === 'gps') {
                useGPS(target);
                exitMapSelectionMode();
            } else {
                exitMapSelectionMode();
                document.getElementById(`${target}Search`).focus();
            }
        });
    });

    // Search input handlers with debounce
    ['origin', 'dest'].forEach(target => {
        const input = document.getElementById(`${target}Search`);
        
        input.addEventListener('input', function() {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                searchLocation(this.value, target);
            }, 300);
        });

        input.addEventListener('focus', function() {
            if (this.value.length >= 3) {
                searchLocation(this.value, target);
            }
        });

        input.addEventListener('blur', function() {
            // Delay hide to allow click on suggestions
            setTimeout(() => hideSuggestions(target), 200);
        });
    });

    // Clear buttons
    document.getElementById('clearOrigin').addEventListener('click', () => clearLocation('origin'));
    document.getElementById('clearDest').addEventListener('click', () => clearLocation('dest'));

    // Search button
    document.getElementById('searchBtn').addEventListener('click', searchRoutes);

    // Close map selection mode on escape
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            exitMapSelectionMode();
        }
    });

    // Initialize
    initMap();
</script>
{% endblock %}
