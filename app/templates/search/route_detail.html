{% extends "base.html" %}

{% block title %}Route Details - Best Bike Paths{% endblock %}

{% block extra_css %}
<style>
    .obstacle-marker {
        background: transparent;
        border: none;
        font-size: 20px;
    }
    #mapContainer {
        position: relative;
    }
    .map-loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 255, 0.8);
        z-index: 1000;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
    }
    .map-loading-overlay.hidden {
        display: none;
    }
    .map-loading-overlay .spinner-border {
        width: 3rem;
        height: 3rem;
    }
    .map-loading-overlay .loading-text {
        margin-top: 10px;
        font-weight: 500;
        color: #198754;
    }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid p-3">
    <div class="d-flex justify-content-between align-items-center mb-3">
        <h2>Route Details</h2>
        <a href="/search" class="btn btn-outline-secondary">
            <i class="bi bi-arrow-left"></i> Back to Search
        </a>
    </div>

    <div id="routeContent">
        <div class="loading-spinner">
            <div class="spinner-border text-success"></div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
    const routeId = '{{ route_id }}';
    
    // cache for osrm routes so we dont request the same thing twice
    const osrmCache = new Map();

    // get obstacal icon based on type
    function getObstacleIcon(type) {
        const icons = {
            'POTHOLE': 'üï≥Ô∏è',
            'ROUGH_SURFACE': 'ü™®',
            'DEBRIS': 'üóëÔ∏è',
            'CONSTRUCTION': 'üöß',
            'OTHER': '‚ö†Ô∏è'
        };
        return icons[type] || '‚ö†Ô∏è';
    }
    
    // get obstacal label for display
    function getObstacleLabel(type) {
        const labels = {
            'POTHOLE': 'Pothole',
            'ROUGH_SURFACE': 'Rough Surface',
            'DEBRIS': 'Debris',
            'CONSTRUCTION': 'Construction',
            'OTHER': 'Other Obstacle'
        };
        return labels[type] || type;
    }

    // decode polyline from osrm (google polyline encodng)
    function decodePolyline(encoded) {
        let points = [];
        let index = 0, lat = 0, lng = 0;

        while (index < encoded.length) {
            let b, shift = 0, result = 0;
            do {
                b = encoded.charCodeAt(index++) - 63;
                result |= (b & 0x1f) << shift;
                shift += 5;
            } while (b >= 0x20);
            let dlat = ((result & 1) ? ~(result >> 1) : (result >> 1));
            lat += dlat;

            shift = 0;
            result = 0;
            do {
                b = encoded.charCodeAt(index++) - 63;
                result |= (b & 0x1f) << shift;
                shift += 5;
            } while (b >= 0x20);
            let dlng = ((result & 1) ? ~(result >> 1) : (result >> 1));
            lng += dlng;

            points.push([lat / 1e5, lng / 1e5]);
        }
        return points;
    }

    // get route from osrm for roads (with cacheing)
    async function getRouteOnRoad(startLat, startLng, endLat, endLng) {
        const cacheKey = `${startLat},${startLng}-${endLat},${endLng}`;
        
        // check cache first
        if (osrmCache.has(cacheKey)) {
            return osrmCache.get(cacheKey);
        }
        
        try {
            const url = `https://router.project-osrm.org/route/v1/bike/${startLng},${startLat};${endLng},${endLat}?overview=full&geometries=polyline`;
            
            const response = await fetch(url);
            const data = await response.json();
            
            if (data.code === 'Ok' && data.routes && data.routes.length > 0) {
                const decoded = decodePolyline(data.routes[0].geometry);
                osrmCache.set(cacheKey, decoded);
                return decoded;
            }
            return null;
        } catch (error) {
            console.error('Error fetching route from OSRM:', error);
            return null;
        }
    }

    async function loadRouteDetails() {
        try {
            const route = await API.paths.getDetail(routeId);

            let html = `
                <div class="card mb-3">
                    <div class="card-body">
                        <h4>${route.name || 'Route'}</h4>
                        ${route.description ? `<p class="text-muted">${route.description}</p>` : ''}
                        <div class="row mt-3">
                            <div class="col-md-3">
                                <div class="text-center">
                                    <div class="h3 text-success">${formatDistanceKm(route.totalDistance)}</div>
                                    <div class="small text-muted">Total Distance</div>
                                </div>
                            </div>
                            <div class="col-md-3">
                                <div class="text-center">
                                    <div class="h3 text-success">${route.score.toFixed(0)}</div>
                                    <div class="small text-muted">Accessibility Score</div>
                                </div>
                            </div>
                            <div class="col-md-3">
                                <div class="text-center">
                                    <div class="h3 text-success">${route.segments.length}</div>
                                    <div class="small text-muted">Segments</div>
                                </div>
                            </div>
                            <div class="col-md-3">
                                <div class="text-center">
                                    <div class="h3 text-success">${route.dataSource}</div>
                                    <div class="small text-muted">Source</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="map-container mb-3" id="mapContainer">
                    <div class="map-loading-overlay" id="mapLoadingOverlay">
                        <div class="spinner-border text-success" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <div class="loading-text">Loading route on map...</div>
                    </div>
                </div>

                <div class="card">
                    <div class="card-body">
                        <h5 class="card-title mb-3">Segments</h5>
            `;

            route.segments.forEach((segment, index) => {
                const badgeClass = getStatusBadgeClass(segment.status);
                html += `
                    <div class="segment-item status-${segment.status.toLowerCase()} mb-3">
                        <div class="d-flex justify-content-between align-items-start">
                            <div>
                                <h6>Segment ${index + 1} ${segment.streetName ? `- ${segment.streetName}` : ''}</h6>
                                <span class="badge ${badgeClass}">${segment.status.replace('_', ' ')}</span>
                            </div>
                        </div>
                        ${segment.obstacles.length > 0 ? `
                            <div class="mt-2">
                                <strong>Obstacles:</strong>
                                <ul class="mb-0 mt-1">
                                    ${segment.obstacles.map(obs => `
                                        <li>
                                            ${getObstacleIcon(obs.type)} <strong>${getObstacleLabel(obs.type)}</strong>
                                            <span class="badge bg-warning text-dark ms-1">${obs.severity}</span>
                                            ${obs.description ? `- ${obs.description}` : ''}
                                        </li>
                                    `).join('')}
                                </ul>
                            </div>
                        ` : ''}
                    </div>
                `;
            });

            html += `
                    </div>
                </div>
            `;

            document.getElementById('routeContent').innerHTML = html;

            // init map
            const map = L.map('mapContainer').setView([route.segments[0].startLatitude, route.segments[0].startLongitude], 14);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }).addTo(map);

            const statusColors = {
                'OPTIMAL': '#28a745',
                'MEDIUM': '#ffc107', 
                'SUFFICIENT': '#fd7e14',
                'REQUIRES_MAINTENANCE': '#dc3545'
            };

            // fetch all osrm routes in paralell (way faster)
            const routePromises = route.segments.map(async (segment) => {
                const roadRoute = await getRouteOnRoad(
                    segment.startLatitude, segment.startLongitude,
                    segment.endLatitude, segment.endLongitude
                );
                
                if (roadRoute && roadRoute.length > 0) {
                    return roadRoute;
                } else {
                    // fallback to strait line if osrm fails
                    return [
                        [segment.startLatitude, segment.startLongitude],
                        [segment.endLatitude, segment.endLongitude]
                    ];
                }
            });

            // wait for all routes to be fetced
            const allCoords = await Promise.all(routePromises);
            const allBounds = [];

            // draw all segmets
            route.segments.forEach((segment, index) => {
                const color = statusColors[segment.status] || '#6c757d';
                const coords = allCoords[index];

                // add points to bounds
                coords.forEach(coord => allBounds.push(coord));

                L.polyline(coords, {
                    color: color,
                    weight: 5,
                    opacity: 0.8
                }).addTo(map).bindPopup(`Segment ${index + 1}: ${segment.status}`);

                // draw obstacels with specific icons
                segment.obstacles.forEach(obstacle => {
                    L.marker([obstacle.latitude, obstacle.longitude], {
                        icon: L.divIcon({
                            className: 'obstacle-marker',
                            html: `<span style="font-size: 24px; filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.5));">${getObstacleIcon(obstacle.type)}</span>`,
                            iconSize: [24, 24],
                            iconAnchor: [12, 12]
                        })
                    }).addTo(map)
                    .bindPopup(`
                        <strong>${getObstacleIcon(obstacle.type)} ${getObstacleLabel(obstacle.type)}</strong><br>
                        Severity: ${obstacle.severity}<br>
                        ${obstacle.description ? obstacle.description : ''}
                    `);
                });
            });

            // fit map to show all the route segmnets
            if (allBounds.length > 0) {
                map.fitBounds(allBounds, { padding: [30, 30] });
            }
            
            // hide loadng overlay
            document.getElementById('mapLoadingOverlay').classList.add('hidden');

        } catch (error) {
            document.getElementById('routeContent').innerHTML = `
                <div class="alert alert-danger">Failed to load route details: ${error.message}</div>
            `;
        }
    }

    loadRouteDetails();
</script>
{% endblock %}
